---
title: Android面试专题：Java基础知识点
titleTemplate: 《Android面试宝典》系列
description: Android面试专题：Java基础知识点、《Android面试宝典》系列
editLink: false
---

# 📚 Android 面试专题：Java 基础知识点

## 一、 基础语法

### 1. 数据类型

---

#### 1.1 Java 有哪些数据类型？

- **基本数据类型**：`byte`、`short`、`int`、`long`、`float`、`double`、`char`、`boolean`

  > `byte`、`boolean` 占用 1 字节，`short`、`char` 占用 2 字节，`int`、`float` 占用 4 字节，`long`、`double` 占用 8 字节

- **引用数据类型**：`class`、`interface`、`[]`

#### 1.2 int 与 Integer 的区别：

- `int` 是 Java 中的一种基本数据类型，可以直接存储数据的值，默认值是 0；
- `Integer` 是 `int` 的包装类，必须实例化才能使用，当**new**一个 `Integer` 时，实际是生成一个指向此对象的引用，默认值是 null；

### 2. 运算符

---

#### 2.1 Java 中 == 和 equals 和 hashCode 的区别：[详解](./special/1.md)

- **==** 用于比较基本数据类型的 **值**或引用数据类型的 **内存地址**；
- `equals()` 是 `Object` 类中定义的一个方法，默认比较对象的内存地址是否相等（是不是同一个对象），一般会重写类的 `equals()` 方法，比较对象的内容是否相同（来判断对象是否相等）；

- `hashCode()` 也是`Object` 类中定义的一个方法，默认返回一个**离散的 int 型整数** ，一般计算出对象实例的哈希码，在对象进行散列时作为 key 存入。

- **equals 和 hashCode 的关系:**
- `hashCode()` 是一个本地方法，实现是根据本地机器上关的；
- `equals()` 相等的对象，`hashCode()` 也一定相等；
- `equals()` 不相等的对象，`hashCode()` 有可能相等；
- `hashCode()` 不等的对象，`equals()` 一定也不等；
- `hashCode()` 相等的对象，`equals()` 可能相等，也可能不等。

### 3. 字符串

---

#### 3.1 String、StringBuffer、StringBuilder 的异同

- 相同：都是字符串，都使用字符数组保存字符串；
- 区别：`String` 类使用 `final` 修饰符，`String` 对象是不可变的，每次对 `String` 操作都会生成新的 `String` 对象，这个样效率低且浪费内存空间，但是线程安全；而 `StringBuffer` 和 `StringBuild` 对象是可变的，既对字符串进行 `append` 操作，不会产生新的对象，它们的区别是：`StringBuffer` 对方法加了同步锁，是线程安全的，`StringBuild` 线程不安全，但效率略高于 `StringBuffer`（确保单线程下可用）

#### 3.2 String 转换成 Integer 的方式及原理：

    1）`Integer.parseInt(String s)` 内部调用 `parseInt(s, 10)`，默认为 10 进制 。

    2）正常判断 `null`、进制范围、`length` 等。

    3）判断第一个字符是否是符号位。

    4）循环遍历确定每个字符的十进制值。

    5）通过\*=和-=进行计算拼接。

    6）判断是否为负值返回结果

## 二、面向对象

### 5. 封装、继承、多态

---

#### 5.1 谈谈对 java 多态的理解

同一个消息可以根据发送对象的不同而采用多种不同的行为方式，在执行期间判断所引用的
对象的实际类型，根据其实际的类型调用其相应的方法。
作用：消除类型之间的耦合关系。实现多态的必要条件：继承、重写（因为必须调用父类中
存在的方法）、父类引用指向子类对象

#### 5.2 父类的静态属性和静态方法是否可以被子类继承？是否可以被子类重写？以及原因？

子类**可以继承**父类静态方法和属性，但是子类**不可重写**父类的静态方法和属性而是被隐藏
如果子类定义了静态属性和方法，那么这时候父类的静态属性和方法称之隐藏；如果您想调用父类的静态属性和方法，直接通过父类名.变量名或方法完成

> 如父类和子类都有同名同参同返回值的静态方法 `show()`，声明的实例 `Father father = new Son();` `(Son extends Father)`，会调用 `father` 对象的静态方法。静态是指在编译时就会分配内存且一直存在，跟对象实例无关

### 6. 内部类

---

#### 6.1 什么是内部类？内部类的作用[详解](./special/2.md)

内部类指在类的内部再定义一个类，`Java` 中内部类主要分为：**成员内部类**、**局部内部类**、**匿名内部类**、**静态内部类**。

**内部类的作用**：① 实现多重继承，因为 `java` 不支持多继承，使用内部类可用实现多个接口（多重继承）；② 内部类可以很好的实现隐藏，一般非内部类不允许有 `private`、`protected` 权限，但内部类可以；③ 减少了类文件编译后产生的字节码文件大小；④ 非静态内部类可以直接访问外部类的属性

#### 6.2 成员部类、局部内部类、匿名内部类、静态内部类的理解，以及项目中的应用

`Java` 中内部类主要分为**成员内部类**、**局部内部类**（嵌套在方法和作用域内）、**匿名内部类**（没有构造方法）、**静态内部类**（static 修饰的类，不依赖外部类，不能使用任何外部类的非 static 成员变量和方法）。

使用内部类最吸引人的原因是：每个内部类都能独立的继承一个（接口的）实现，所以无论外部类是否已经继承了某个（接口的）实现，对于内部类都没有影响。

因为 Java 不支持多继承，支持实现多个接口。都有时候会存在一些使用接口很难解决的问题，这个时候我们可以利用内部类提供的、可以继承多个具体的或者抽象的类的能力来解决程序设计问题。可以这样说，接口只是解决了部分问题，而内部类使得多重继承的解决方案变得更加完美。

### 7. 抽象类和接口

---

#### 7.1 抽象类和接口的区别[详解](./special/3.md)

- **抽象类**可以提供成员方法实现的细节，而**接口**只能存在抽象方法；
- **抽象类**的成员变量可以是各种类型，而**接口**中成员变量只能是 `public static final` 类型；
- **抽象类**可以有静态方法和静态代码块，而**接口**中不能含有静态方法及静态代码块；
- 一个类只能继承一个**抽象类**（用 `extends` 来继承），却可以实现多个接口（用 `implements` 来实现接口）。

### 8. 数组和集合

### 9. 反射与泛型

#### 9.1 泛型中 extends 和 super 的区别

`<? extends T>` 限定参数类型的上界，参数类型必须是 `T` 或 `T` 的子类，但对于 `List<? extends T>` 不能通过 `add()` 来添加元素，因为不知道 `<? extends T>` 是 `T` 的哪一种子类；
`<? super T>` 限定参数类型的下界，参数类型必须是 `T` 或 `T` 的父类型，不能通过 `get()` 获取元素，因为不知道哪个超类；

### 10. 注解

### 11. 异常

### 12. I/O 流

### 13. 多线程

---

#### 13.1 进程和线程的关系、区别

**进程**：具有一定功能的程序，是系统进行资源（CPU、内存等）分配和调度运行的基本单位；

**线程**：进程的一个实体，是 CPU 调度的基本单位，也是进程中执行运算的最小单位，既执行处理机调度的基本单位，如果把进程理解为逻辑上操作系统所完成的任务，线程则表示完成
该任务的许多可能的子任务之一；

**关系**：一个进程内可有多个线程（至少一个），一个线程只能属于一个进程；同一进程的所有线程共享该进程的所有资源；不同进程的线程间要利用消息通信方式实现同步。

**区别**：进程有独立的地址空间，进程间不能共享资源，而线程共享所在进程的地址空间和其他资源；进程具有一个独立功能的程序，线程不能独立运行，必须依存于应用程序中。

## 三、网络编程

### 15. 序列化

---

#### 15.2 序列化 Serializable 和 Parcelable 的区别 [详解](./special/15.md)

- **Serializable**：Java 序列化接口。在硬盘上读写，读写过程中有大量临时变量的生成，内部执行大量的 I/O 操作，效率很低；
- **Parcelable**：Android 序列化接口。在内存中读写，效率高，使用麻烦（AS 有相关插件，一键生成所需方法），对象不能保存到磁盘中

---

### 五、综合

#### 15.1 final、finally、finalize 的区别

**final**：类、变量、方法的修饰符，被 `final` 修饰的类不可被继承、变量不可变、方法不可重写；

**finally**：异常处理时提供 `finally` 语句块来执行清除操作，不管有没有异常抛出，此处代码都会被执行；如果 `try` 语句块中包含 `return` 语句，`finally` 语句块是在 `return` 之后执行；

**finalze**：`Object` 类中定义的方法，若子类覆盖了 `finalze()` 方法，在垃圾收集器将对象从内存中清除前，会执行该方法，确定对象是否会被回收；

#### 15.2 谈谈对 Kotlin 的理解

**特点**：① 代码量少且代码末尾没有分号；② 空类型安全（编译器处理了各种 null 情况，避免执行时异常）；③ 函数式的，可使用 `lambda` 表达式; ④ 可扩展方式（可扩展任意类的属性）；⑤ 互操作性强，可在一个项目中使用 `kotlin` 和 `java` 两种语言混合开发。

[Java 深入源码级的面试题](./source.md)
